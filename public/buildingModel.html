<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Building X-Ray Renderer</title>
    <style>
        body { margin: 0; }
        canvas { width: 100%; height: 100%; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .control-btn {
            padding: 8px 16px;
            background: rgba(0,0,0,0.5);
            color: white;
            border: 1px solid white;
            border-radius: 5px;
            cursor: pointer;
        }
        .control-btn:hover {
            background: rgba(0,0,0,0.7);
        }
        .modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8);
            padding: 20px;
            border-radius: 10px;
            color: white;
            text-align: center;
        }
        .modal input {
            margin: 10px;
            padding: 5px;
        }
        .modal button {
            margin: 5px;
            padding: 5px 10px;
            background: rgba(255,255,255,0.2);
            border: 1px solid white;
            color: white;
            cursor: pointer;
            border-radius: 3px;
        }
        .modal button:hover {
            background: rgba(255,255,255,0.3);
        }
        .worker {
            position: absolute;
            width: 32px;
            height: 32px;
            background-color: yellow;
            }

        .quadrant-menu {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid white;
            border-radius: 5px;
            padding: 5px 0;
            z-index: 1000 !important;
        }

        .quadrant-menu-item {
            padding: 8px 20px;
            color: white;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .quadrant-menu-item:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
    </style>
</head>
<body>
    <div id="instructions">
        W/S: Forward/Back<br>
        A/D: Left/Right<br>
        Q/E: Up/Down<br>
        Arrows: Rotate
    </div>

    <div id="controls">
        <button class="control-btn" id="wifiConfig">Add WIFI</button>
        <button class="control-btn" id="lobbyFloor">Define Lobby Floor</button>
        <button class="control-btn" id="rojiBoxes">Show Roji Boxes</button>
        <button class="control-btn" id="toggleElevators">Add elevators</button>
        <button class="control-btn" id="floorAmount">Define floor amount</button>
        <button class="control-btn" id="toggleWorkers">Show Workers</button>
    </div>
    <div id="floorInfoModal" class="modal">
        <h3 id="floorInfoTitle"></h3>
        <div id="floorInfoContent">
            <img
                id="floorImage"
                src="floor.png"
                style="height: 70%; width: 70%; cursor: pointer;"
                onclick="replaceWithIframe('https://player.castr.com/live_1deb88e0b56e11ef8f0e3fcb84ef4d27')"
            >
        </div>
        <button onclick="restoreImage()">Close</button>
    </div>

    <div id="singleCameraModal" class="modal">
        <h3 id="singleCameraTitle"></h3>
        <div id="singleCameraContent">
            <img id="floorImage" src="floor.png" style="height: 70%; width: 70%; cursor: pointer;"
                onclick="replaceWithIframe('https://player.castr.com/live_1deb88e0b56e11ef8f0e3fcb84ef4d27')">
        </div>
        <button onclick="restoreImage()">Close</button>
    </div>

    <div id="floorModal" class="modal">
        <h3>Enter number of floors:</h3>
        <input type="number" id="floorInput" min="1" max="100" value="25">
        <br>
        <button onclick="updateFloors()">Apply</button>
        <button onclick="document.getElementById('floorModal').style.display='none'">Cancel</button>
    </div>
    <div id="lobbyFloorModal" class="modal">
        <h3>Enter number of floors:</h3>
        <input type="number" id="lobbyFloorInput" min="0" max="100" value="0">
        <br>
        <button onclick="updateLobbyFloor()">Set</button>
        <button onclick="document.getElementById('lobbyFloorModal').style.display='none'">Cancel</button>
    </div>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "OBJLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/OBJLoader.js",
                "MTLLoader": "https://unpkg.com/three@0.160.0/examples/jsm/loaders/MTLLoader.js"
            }
        }
    </script>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/0.160.0/three.module.min.js';
        import {OBJLoader} from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/OBJLoader.js';
        import {GLTFLoader} from 'https://unpkg.com/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

        // Make THREE available globally for your existing code
        window.THREE = THREE;

        window.onload = function() {
            let scene, camera, renderer, controls, raycaster, mouse;
            window.activeFloorGroup = null;
            let isAnimating = false;
            let extendedFloor = null;
            let totalFloors = 25;
            const buildingWidth = 30;
            const buildingDepth = 16;
            const floorHeight = 3;
            const wallThickness = 0.1;
            let rojiBoxes = [];
            let elevators = [];
            let rojiBlinkInterval;
            let isRojiVisible = false;
            let isElevatorsVisible = true;
            //let wifiFloors = new Set([0,1,2,3,4,5,6,7,8,9]);
            let wifiFloors = new Set();
            let workers = [];
            let isWorkersVisible = false;
            let floorsNames = [];
            let dangerousQuadrants = new Set(); // Store dangerous quadrant identifiers
            let activeItems = [];
            let currentZones = [];
            let itemTitle = null;
            let titleSprite = null;
            window.activeMenu = null;
            let blinkingItems = new Set();
            let lastBlinkTime = 0;
            const blinkInterval = 500;
            let loaded_models = {
                ppl: { path: 'models/safety_helmet.glb', obj: null }
            };

             window.addEventListener('message', function (event) {
                // Handle messages from the parent window
                if (event.data.type === 'FLOOR_TOGGLE') {
                    const { floorNumber, action } = event.data;

                    if (action === 'expand') {
                        // Call your existing floor animation function
                        createAnimatedFloorView(floorNumber);
                    } else if (action === 'collapse') {
                        // Reset the floor position
                        resetFloorPosition();
                    }
                }
                if (event.data.type === 'SHOW_ITEMS') {
                     const { title, type, items } = event.data.data;

                     // Clear any existing items
                     clearExistingItems();

                     // Create and position title
                     titleSprite = createTextSprite(title);
                     titleSprite.position.set(0, totalFloors * floorHeight + 10, 0);
                     titleSprite.scale.set(15, 4, 1);
                     scene.add(titleSprite);
                     activeItems.push(titleSprite);

                     // Create and position items
                     items.forEach(item => {
                         const label = createTextSprite(item.tag_id, 40);

                         const { floor_physical, xy, is_exact } = item.location;
                         const worldCoords = normalizedToWorldCoords(xy[0], xy[1], buildingWidth, buildingDepth);

                         let finalX = worldCoords.x;
                         let finalZ = worldCoords.z;

                         if (!is_exact) {
                             finalX = addRandomization(finalX, 2);
                             finalZ = addRandomization(finalZ, 2);
                         }

                         const y = floor_physical * floorHeight + (floorHeight / 2);

                         createItemSprite(type, finalX, y, finalZ);


                         label.position.set(finalX, y + 1.5, finalZ);
                         label.scale.set(5, 1, 1);
                         scene.add(label);
                         activeItems.push(label);

                     });

                     // // Reset camera to show all items
                     // resetCameraToShowItems();
                 }
            }, false);

            function createTextSprite(text, size = 70) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 128;
                const context = canvas.getContext('2d');

                context.fillStyle = 'white';
                context.fillRect(0, 0, canvas.width, canvas.height);
                context.fillStyle = 'black';
                context.font = `${size}px Arial`;
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                return new THREE.Sprite(spriteMaterial);
            }

            function addZone(zone) {
                const { name, is_wifi, is_dangerous, location } = zone;
                const { floor_physical, xy, is_exact } = location;
                const zoneGeometry = new THREE.BoxGeometry(buildingWidth/2 - 1, 0.3, buildingDepth/2 - 1);
                const material = new THREE.MeshStandardMaterial({
                  emissive: is_dangerous? 0xff0000 : is_wifi? 0xFFFF00 : 0x0000FF,
                  color: 0x000000,
                  emissiveIntensity: 1, // Glow intensity
                  transparent: true,
                  opacity: 0.4
                });
                const zoneMesh = new THREE.Mesh(zoneGeometry, material);
                zoneMesh.name = `zone-${name}`;
                const worldCoords = normalizedToWorldCoords(xy[0], xy[1], buildingWidth, buildingDepth);
                let finalX = worldCoords.x;
                let finalZ = worldCoords.z;

                if (!is_exact) {
                    finalX = addRandomization(finalX, 2);
                    finalZ = addRandomization(finalZ, 2);
                }

                const y = floor_physical * floorHeight + (floorHeight / 2);
                zoneMesh.position.set(finalX, y, finalZ);
                if (window.extendedFloor !== null && window.extendedFloor === floor_physical) {
                    window.activeFloorGroup.add(zoneMesh);
                    let clone = zoneMesh.clone();
                    clone.visible = false
                    scene.add(clone);
                    currentZones.push(clone);
                    window.activeFloorGroup.originalComponents.push(clone);
                } else {
                    scene.add(zoneMesh);
                }
                currentZones.push(zoneMesh);
            }

            function createItemSprite(type, x, y, z) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                if (type === 'ppl') {
                    if (!loaded_models[type]['obj']) {
                        console.log(`Loading model for ${type}`);
                        const loader = new GLTFLoader();
                        loader.load(loaded_models[type]['path'], function (gltf) {
                            const model = gltf.scene
                            model.scale.set(0.7, 0.7, 0.7);
                            const isRed = Math.random() < 1 / 3;
                            const modelColor = isRed ? 0xff0000 : 0xffff00;
                            model.traverse(child => {
                                if (child.isMesh) {
                                    child.material = new THREE.MeshBasicMaterial({ color: modelColor });
                                }
                            });
                            loaded_models[type]['obj'] = model;
                            model.position.set(x, y, z);
                            scene.add(model);
                            activeItems.push(model);
                        });
                    } else {
                        let model = loaded_models[type]['obj'].clone();
                        model.position.set(x, y, z);
                        const isRed = Math.random() < 1 / 3;
                        const modelColor = isRed ? 0xff0000 : 0xffff00;
                        model.traverse(child => {
                            if (child.isMesh) {
                                child.material = new THREE.MeshBasicMaterial({ color: modelColor });
                            }
                        });
                        scene.add(model);
                        activeItems.push(model);
                    }
                } else if (type === 'equipment') {
                    // Create a larger, brighter sphere for equipment
                    const geometry = new THREE.SphereGeometry(1, 32, 32);
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xff0000,  // Bright red
                        specular: 0xffffff,
                        shininess: 100,
                        transparent: true,
                        opacity: 1
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(x, y, z);
                    scene.add(sphere);
                    activeItems.push(sphere);
                    blinkingItems.add(sphere);

                    // Add a glowing effect
                    const glowGeometry = new THREE.SphereGeometry(1.2, 32, 32);
                    const glowMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff0000,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    sphere.add(glow);

                } else if (type === 'sensors') {
                    // Create a brighter, more visible sphere for sensors
                    const geometry = new THREE.SphereGeometry(0.8, 32, 32);
                    const material = new THREE.MeshPhongMaterial({
                        color: 0xff3333,  // Bright red
                        specular: 0xffffff,
                        shininess: 100,
                        transparent: true,
                        opacity: 1
                    });
                    const sphere = new THREE.Mesh(geometry, material);
                    sphere.position.set(x, y, z);
                    scene.add(sphere);
                    activeItems.push(sphere);
                    blinkingItems.add(sphere);

                    // Add a glowing effect
                    const glowGeometry = new THREE.SphereGeometry(1, 32, 32);
                    const glowMaterial = new THREE.MeshPhongMaterial({
                        color: 0xff3333,
                        transparent: true,
                        opacity: 0.3
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    sphere.add(glow);
                }

                return null; // If no sprite was created (e.g., when using 3D models)
            }

            // Add this function to convert normalized coordinates to world coordinates
            function normalizedToWorldCoords(x, y, floorWidth, floorDepth) {
                const worldX = (x / 100 * floorWidth) - (floorWidth / 2);
                const worldZ = (y / 100 * floorDepth) - (floorDepth / 2);
                return { x: worldX, z: worldZ };
            }

            // Add this function to add randomization to coordinates if needed
            function addRandomization(coord, range) {
                const randomOffset = (Math.random() - 0.5) * range;
                return coord + randomOffset;
            }

            // Add this function to clear existing items
            function clearExistingItems() {
                activeItems.forEach(item => {
                    scene.remove(item);
                });
                activeItems = [];

                if (titleSprite) {
                    scene.remove(titleSprite);
                    titleSprite = null;
                }
            }

            function createHelmetSprite(color) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                // Draw helmet
                ctx.beginPath();
                ctx.fillStyle = color;
                ctx.moveTo(10, 40);
                ctx.bezierCurveTo(10, 20, 54, 20, 54, 40);
                ctx.lineTo(54, 45);
                ctx.quadraticCurveTo(32, 50, 10, 45);
                ctx.closePath();
                ctx.fill();

                // Draw helmet brim
                ctx.beginPath();
                ctx.moveTo(5, 40);
                ctx.lineTo(59, 40);
                ctx.lineTo(57, 43);
                ctx.lineTo(7, 43);
                ctx.closePath();
                ctx.fill();

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                return new THREE.Sprite(spriteMaterial);
            }

            function createNumberSprite(number) {
                const canvas = document.createElement('canvas');
                canvas.width = 64;
                canvas.height = 64;
                const ctx = canvas.getContext('2d');

                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(number.toString(), 32, 32);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ 
                    map: texture,
                    transparent: true
                });
                return new THREE.Sprite(spriteMaterial);
            }

            function init() {
                scene = new THREE.Scene();
                scene.background  = new THREE.Color(0xffffff);
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                mouse = new THREE.Vector2();
                raycaster = new THREE.Raycaster();
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Add click event listener to renderer
                renderer.domElement.addEventListener('click', onMouseClick, false);

                // Initialize controls globally
                // controls = new OrbitControls(camera, renderer.domElement);
                // controls.enableDamping = true;
                // controls.dampingFactor = 0.05;
                // controls.screenSpacePanning = false;
                // controls.minDistance = 10;
                // controls.maxDistance = 500;
                // controls.maxPolarAngle = Math.PI / 2;

                createBuilding();
                // createBuildingLines();

                camera.position.set(0, totalFloors * floorHeight / 2, totalFloors * 2.5);
                // camera.lookAt(0, totalFloors * floorHeight / 2, 0);
                raycaster.setFromCamera(mouse, camera);
                
                
                animate();
            }

            const materials = {
                floor: new THREE.MeshBasicMaterial({
                    color: 0xcccccc,
                    transparent: true,
                    opacity: 0.2
                }),
                // floor: new THREE.MeshPhongMaterial({
                //     color: 0xcccccc,
                //     specular: 16777215,
                //     emissive: 0,
                //     shininess: 10,
                //     transparent: true,
                //     opacity: 0.2,
                //     depthWrite: false,
                    
                // }),
                underground: new THREE.MeshBasicMaterial({
                    color: 0x039BE5,
                    transparent: true,
                    opacity: 0.3
                }),
                elevator: new THREE.MeshBasicMaterial({
                    color: 0x0066ff,
                    transparent: true,
                    opacity: 0.5
                }),
                stair: new THREE.MeshBasicMaterial({
                    color: 0x00ff66,
                    transparent: true,
                    opacity: 0.6
                }),
                stairStep: new THREE.MeshBasicMaterial({
                    color: 0x888888,
                    transparent: false,
                    opacity: 1
                }),
                line: new THREE.LineBasicMaterial({
                    color: 0x113131,
                    linewidth: 1
                }),
                rojiLight: new THREE.SpriteMaterial({
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.8,
                    depthTest: false
                })
            };

            function createWarningSign() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // Draw warning triangle
                ctx.beginPath();
                ctx.fillStyle = 'yellow';
                ctx.moveTo(128, 40);
                ctx.lineTo(216, 200);
                ctx.lineTo(40, 200);
                ctx.closePath();
                ctx.fill();
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 10;
                ctx.stroke();

                // Draw exclamation mark
                ctx.fillStyle = 'black';
                ctx.font = 'bold 100px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('!', 128, 140);

                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);
                sprite.scale.set(2, 2, 1);
                return sprite;
            }

            function createFloorLabel(floor, yPosition) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 1024;
                canvas.height = 1024;
                context.font = 'Bold 400px Arial';
                context.fillStyle = 'black';
                context.textAlign = 'center';
                let floorName = floorsNames[`${floor}`] || `${floor}`;
                context.fillText(floorName, 512, 612);

                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.set(-buildingWidth/2 - 6, yPosition + floorHeight/2, 0);
                sprite.scale.set(8, 4, 1);
                scene.add(sprite);
            }

            function createRojiBoxes() {
                rojiBoxes.forEach(box => scene.remove(box));
                rojiBoxes = [];

                for (let floor = 0; floor < totalFloors; floor++) {
                    const stairLight = new THREE.Sprite(materials.rojiLight.clone());
                    stairLight.scale.set(0.4, 0.4, 0.4);
                    stairLight.position.set(
                        buildingWidth/2 - 3,
                        floor * floorHeight + floorHeight/2,
                        1.2
                    );

                    const elevatorLight = new THREE.Sprite(materials.rojiLight.clone());
                    elevatorLight.scale.set(0.4, 0.4, 0.4);
                    elevatorLight.position.set(
                       2,
                       floor * floorHeight + floorHeight/2,
                       buildingDepth/2
                   );

                    scene.add(stairLight);
                    scene.add(elevatorLight);
                    rojiBoxes.push(stairLight, elevatorLight);
                }
            }

            function toggleRojiBoxes() {
                const btn = document.getElementById('rojiBoxes');
                if (!isRojiVisible) {
                    createRojiBoxes();
                    rojiBlinkInterval = setInterval(() => {
                        rojiBoxes.forEach(box => {
                            box.material.opacity = box.material.opacity === 0.8 ? 0.2 : 0.8;
                        });
                    }, 300);
                    btn.textContent = 'Hide Roji Boxes';
                } else {
                    clearInterval(rojiBlinkInterval);
                    rojiBoxes.forEach(box => scene.remove(box));
                    rojiBoxes = [];
                    btn.textContent = 'Show Roji Boxes';
                }
                isRojiVisible = !isRojiVisible;
            }

            function createElevators() {
                // Create the main elevator shafts first
                for (let floor = 0; floor < totalFloors; floor++) {
                    const elevator1 = new THREE.Mesh(
                        new THREE.BoxGeometry(2.5, floorHeight, 2.5),
                        materials.elevator
                    );
                    elevator1.position.set(
                        0,
                        floor * floorHeight + floorHeight/2,
                        -buildingDepth/2 - 2
                    );

                    const elevator2 = new THREE.Mesh(
                        new THREE.BoxGeometry(2.5, floorHeight, 2.5),
                        materials.elevator
                    );
                    elevator2.position.set(
                        4,
                        floor * floorHeight + floorHeight/2,
                        -buildingDepth/2 - 2
                    )

                    scene.add(elevator1);
                    scene.add(elevator2);

                    elevators.push(elevator1, elevator2);
                }
            }

            function resetFloorPosition() {
                if (!window.activeFloorGroup || isAnimating) return;
                createAnimatedFloorView(null);
            }

            function removeElevators() {
                elevators.forEach(elevator => scene.remove(elevator));
                elevators = [];
            }

            function toggleElevators() {
                const btn = document.getElementById('toggleElevators');
                if (!isElevatorsVisible) {
                    createElevators();
                    btn.textContent = 'Hide elevators';
                } else {
                    removeElevators();
                    btn.textContent = 'Add elevators';
                }
                isElevatorsVisible = !isElevatorsVisible;
            }

            window.restoreImage = function () {
                document.getElementById('floorInfoModal').style.display='none'
                const contentDiv = document.getElementById('floorInfoContent');

                // Clear the existing content
                contentDiv.innerHTML = '';

                // Create a new image element
                const img = document.createElement('img');
                img.id = 'floorImage';
                img.src = 'floor.png';
                img.style.height = '70%';
                img.style.width = '70%';
                img.style.cursor = 'pointer';
                img.onclick = () => replaceWithIframe('https://player.castr.com/live_1deb88e0b56e11ef8f0e3fcb84ef4d27');

                // Add the image back to the content div
                contentDiv.appendChild(img);
            }

            // Define the two camera positions
            // Define a constant lookAt point that won't change during transitions
            const CONSTANT_LOOK_AT = {
                ZOOMED_IN: new THREE.Vector3(0, totalFloors * floorHeight / 2, 0),
                ZOOMED_OUT: new THREE.Vector3(-10, totalFloors * floorHeight / 2, 0),
            }

            const CAMERA_POSITIONS = {
                ZOOMED_IN: new THREE.Vector3(0, totalFloors * floorHeight / 2, totalFloors * 2.5),
                ZOOMED_OUT: new THREE.Vector3(0, totalFloors * floorHeight / 2, totalFloors * 4)
            };

            // Track camera state independently of floor state
            let isCameraZoomedOut = false;

            function createAnimatedFloorView(floorNumber) {
                if (isAnimating) return;
                isAnimating = true;

                // If there's an active floor, retract it first
                if (window.activeFloorGroup) {
                    const currentGroup = window.activeFloorGroup;
                    const slideDistance = buildingWidth * -1.5;
                    let startTime = null;
                    const returnDuration = 1000;

                    function returnAnimation(currentTime) {
                        if (!startTime) startTime = currentTime;
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / returnDuration, 1);
                        const easing = easeInOutCubic(progress);

                        // Animate floor
                        if (progress <= 0.5) {
                            const rotateProgress = 1 - (progress * 2);
                            currentGroup.rotation.x = rotateProgress * Math.PI / 2;
                        }
                        if (progress > 0.5) {
                            const slideProgress = 1 - ((progress - 0.5) * 2);
                            currentGroup.position.x = slideDistance * slideProgress;
                        }

                        // Camera animation - only if we're fully closing the floor view
                        if (floorNumber === null) {
                            camera.position.lerp(CAMERA_POSITIONS.ZOOMED_IN, easing);
                            // camera.lookAt(CONSTANT_LOOK_AT.ZOOMED_IN);
                            raycaster.setFromCamera(mouse, camera);
                            if (progress === 1) {
                                isCameraZoomedOut = false;
                            }
                        }

                        if (progress < 1) {
                            requestAnimationFrame(returnAnimation);
                        } else {
                            if (currentGroup.originalComponents) {
                                currentGroup.originalComponents.forEach(comp => {
                                    comp.visible = true;
                                });
                            }

                            scene.remove(currentGroup);
                            window.activeFloorGroup = null;
                            window.extendedFloor = null;

                            if (floorNumber !== null) {
                                setTimeout(() => {
                                    isAnimating = false;
                                    animateNewFloor(floorNumber);
                                }, 50);
                            } else {
                                isAnimating = false;
                            }
                        }
                    }

                    requestAnimationFrame(returnAnimation);
                } else if (floorNumber !== null) {
                    animateNewFloor(floorNumber);
                }
            }

            function animateNewFloor(floorNumber) {
                isAnimating = true;
                const floorGroup = new THREE.Group();
                const floorY = floorNumber * floorHeight;

                // Helper function to check if an object belongs to this floor
                const isInFloorRange = (position) => {
                    return position.y >= floorY - wallThickness / 2 &&
                        position.y < floorY + floorHeight;
                };

                // Collect and clone floor components
                scene.children.forEach(child => {
                    // if (!child.isMesh && !child.isLine && !child.isLineSegments && !child.isSprite && !child.isCanvasTexture) return;

                    if (isInFloorRange(child.position)) {
                        const clone = child.clone(true);
                        child.visible = false;
                        clone.position.sub(new THREE.Vector3(0, floorY, 0));
                        floorGroup.add(clone);
                        if (child.name && child.name.includes('zone')) {
                            currentZones.push(clone);
                        }

                        if (child.children.length > 0) {
                            child.children.forEach(childObj => {
                                const childClone = childObj.clone(true);
                                clone.add(childClone);
                            });
                        }
                    }
                });

                floorGroup.position.y = floorY;
                scene.add(floorGroup);
                window.activeFloorGroup = floorGroup;

                window.activeFloorGroup.originalComponents = scene.children.filter(child =>
                    isInFloorRange(child.position)
                );
                window.extendedFloor = floorNumber;

                const slideDistance = buildingWidth * -1.5;
                let startTime = null;
                const duration = 1000;

                function slideOutAnimation(currentTime) {
                    if (!startTime) startTime = currentTime;
                    const elapsed = currentTime - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const easing = easeInOutCubic(progress);

                    // Floor animation
                    if (progress <= 0.5) {
                        const slideProgress = progress * 2;
                        floorGroup.position.x = slideDistance * slideProgress;
                    }
                    if (progress > 0.5) {
                        const rotateProgress = (progress - 0.5) * 2;
                        floorGroup.rotation.x = rotateProgress * Math.PI / 2;
                    }

                    // Camera animation - only if we're not already zoomed out
                    if (!isCameraZoomedOut) {
                        camera.position.lerp(CAMERA_POSITIONS.ZOOMED_OUT, easing);
                        // camera.lookAt(CONSTANT_LOOK_AT.ZOOMED_OUT);
                        raycaster.setFromCamera(mouse, camera);
                        if (progress === 1) {
                            isCameraZoomedOut = true;
                        }
                    }

                    if (progress < 1) {
                        requestAnimationFrame(slideOutAnimation);
                    } else {
                        isAnimating = false;
                    }
                }

                requestAnimationFrame(slideOutAnimation);
            }

            function easeInOutCubic(t) {
                return t < 0.5
                    ? 4 * t * t * t
                    : 1 - Math.pow(-2 * t + 2, 3) / 2;
            }




                function createBuilding() {
                const verticalGap = 0.1;
                const sectionHeight = floorHeight - (verticalGap * 2);

                const edgeMaterial = new THREE.LineBasicMaterial({
                    color: 50630,
                    linewidth: 1,
                    linecap: "round",
                    linejoin: "round",
                    transparent: true,
                    opacity: 0.5
                });

                const wallMaterial = new THREE.MeshPhongMaterial({
                    color: 50630,
                    specular: 16777215,
                    emissive: 0,
                    shininess: 10,
                    transparent: true,
                    opacity: 0.2,
                    depthWrite: false,
                    side: THREE.DoubleSide
                });

                for (let floor = 0; floor < totalFloors + 1; floor++) {
                    // Add roof at the top floor
                    if (floor === totalFloors) {
                        const roofGeometry = new THREE.BoxGeometry(buildingWidth, wallThickness, buildingDepth);
                        const roofMesh = new THREE.Mesh(roofGeometry, materials.floor.clone());
                        roofMesh.position.y = floor * floorHeight;
                        scene.add(roofMesh);
                        break;
                    }

                    // Create floor plane
                    const floorGeometry = new THREE.BoxGeometry(buildingWidth, wallThickness, buildingDepth);
                    const floorMaterial = materials.floor.clone();
                    const floorMesh = new THREE.Mesh(floorGeometry, floorMaterial);
                    floorMesh.position.y = floor * floorHeight;
                    floorMesh.isFloor = true;
                    scene.add(floorMesh);

                    // Create the four walls for each floor
                    const walls = [
                        // Left wall
                        {
                            geometry: new THREE.BoxGeometry(wallThickness, sectionHeight, buildingDepth),
                            position: [-buildingWidth / 2, floor * floorHeight + floorHeight / 2, 0]
                        },
                        // Right wall
                        {
                            geometry: new THREE.BoxGeometry(wallThickness, sectionHeight, buildingDepth),
                            position: [buildingWidth / 2, floor * floorHeight + floorHeight / 2, 0]
                        },
                        // Front wall
                        {
                            geometry: new THREE.BoxGeometry(buildingWidth, sectionHeight, wallThickness),
                            position: [0, floor * floorHeight + floorHeight / 2, buildingDepth / 2]
                        },
                        // Back wall
                        {
                            geometry: new THREE.BoxGeometry(buildingWidth, sectionHeight, wallThickness),
                            position: [0, floor * floorHeight + floorHeight / 2, -buildingDepth / 2]
                        }
                    ];

                    walls.forEach(wall => {
                        const wallMesh = new THREE.Mesh(wall.geometry, wallMaterial);
                        wallMesh.position.set(...wall.position);
                        scene.add(wallMesh);

                        // Add edges
                        const edges = new THREE.EdgesGeometry(wallMesh.geometry);
                        const edgeMesh = new THREE.LineSegments(edges, edgeMaterial);
                        edgeMesh.position.copy(wallMesh.position);
                        scene.add(edgeMesh);

                        // Add vertical lines
                        if (wall.geometry.parameters.height > wallThickness) {
                            const numLines = 16; // Increased number of lines for fuller appearance
                            const wallHeight = sectionHeight;
                            const wallWidth = wall.geometry.parameters.width;
                            const step = wallWidth / (numLines + 1);

                            for (let i = 1; i <= numLines; i++) {
                                const offset = -wallWidth / 2 + i * step;

                                let lineStart, lineEnd;

                                if (wall.geometry.parameters.width === buildingWidth) { // Front/back walls
                                    lineStart = new THREE.Vector3(
                                        offset,
                                        -wallHeight / 2,
                                        0
                                    );
                                    lineEnd = new THREE.Vector3(
                                        offset,
                                        wallHeight / 2,
                                        0
                                    );
                                const lineGeometry = new THREE.BufferGeometry().setFromPoints([lineStart, lineEnd]);
                                const verticalLine = new THREE.Line(lineGeometry, edgeMaterial);
                                wallMesh.add(verticalLine);
                                } else { // Left/right walls
                                    lineStart = new THREE.Vector3(
                                        0,
                                        -wallHeight / 2,
                                        offset
                                    );
                                    lineEnd = new THREE.Vector3(
                                        0,
                                        wallHeight / 2,
                                        offset
                                    );
                                }

                            }
                        }
                    });

                    // Create floor label
                    createFloorLabel(floor, floor * floorHeight);

                    // Add stair shaft
                    const stairShaft = new THREE.Mesh(
                        new THREE.BoxGeometry(4, floorHeight, 4),
                        materials.stair
                    );
                    stairShaft.position.set(buildingWidth / 2 - 1.5, floor * floorHeight + floorHeight / 2, 0);
                    scene.add(stairShaft);

                    // Add stairs
                    const stairWidth = 4;
                    const stairLength = floorHeight * Math.sqrt(2) / 3;

                    const stair1 = new THREE.Mesh(
                        new THREE.BoxGeometry(stairWidth, 0.1, stairLength),
                        materials.stairStep
                    );
                    stair1.position.set(
                        buildingWidth / 2 - 1.5,
                        floor * floorHeight + floorHeight / 2,
                        1
                    );
                    stair1.rotation.z = (floor % 2 === 0) ? Math.PI / 5 : -Math.PI / 5;
                    scene.add(stair1);
                }

                // Add lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
                scene.add(ambientLight);

                if (isElevatorsVisible) {
                    createElevators();
                }
                updateWifiFloors();
            }

            function showWifiModal() {
                const container = document.getElementById('wifiFloors');
                container.innerHTML = '';

                for (let i = 0; i < totalFloors; i++) {
                    const div = document.createElement('div');
                    div.innerHTML = `
                        <label>
                            <input type="checkbox" value="${i}"
                                ${wifiFloors.has(i) ? 'checked' : ''}>
                            Floor ${i === 0 ? 'L' : i + 1}
                        </label>
                    `;
                    container.appendChild(div);
                }
                document.getElementById('wifiModal').style.display = 'block';
            }

            function updateWifiFloors() {
                scene.children.forEach(child => {
                    if (child.isFloor) {
                        const floorNumber = Math.round(child.position.y / floorHeight);
                        child.material.color.setHex(wifiFloors.has(floorNumber) ? 0xffff00 : 0xcccccc);
                    }
                });
            }

            function getRandomLocation(buildingWidth, buildingDepth) {
                const marginX = buildingWidth * 0.2;
                const marginY = buildingDepth * 0.2;

                const minX = -buildingWidth / 2 + marginX;
                const maxX = buildingWidth / 2 - marginX;

                const minY = -buildingDepth / 2 + marginY;
                const maxY = buildingDepth / 2 - marginY;

                // Generate random x and y within the central area
                const x = Math.random() * (maxX - minX) + minX;
                const y = Math.random() * (maxY - minY) + minY;

                return { x, y };
            }
            function onMouseClick(event) {
                event.preventDefault();

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);

                // If we have an active floor group
                if (window.activeFloorGroup) {
                    const allIntersects = raycaster.intersectObjects(scene.children, true);
                    if (allIntersects.length > 0) {
                        console.log(allIntersects)
                        const clickedObject = allIntersects[0].object;
                        if (clickedObject.userData.streamUrl) {
                            const { name, streamUrl } = clickedObject.userData;
                            replaceWithIframe(streamUrl);
                            showCameraModal();
                            return;
                        }
                    }
                    const floorIntersects = raycaster.intersectObjects(window.activeFloorGroup.children, true);

                    if (floorIntersects.length > 0) {
                        const clickedObject = floorIntersects[0].object;
                        const floorNumber = Math.round(window.activeFloorGroup.position.y / floorHeight);

                        createFloorMenu(
                            event.clientX,
                            event.clientY,
                            clickedObject,
                            floorNumber
                        );
                        return;
                    }
                }

                // Check all scene objects for regular floor selection
                const sceneIntersects = raycaster.intersectObjects(scene.children, true);

                if (!window.activeFloorGroup) {
                    // Try to find any floor component (floor, wall, or other part)
                    const floorComponent = sceneIntersects.find(intersect => {
                        // Get the Y position of the intersected object
                        const objectY = intersect.object.position.y;
                        // Check if it's a floor or within a floor's height range
                        return intersect.object.isFloor ||
                            (objectY % floorHeight < floorHeight + wallThickness &&
                                objectY % floorHeight > -wallThickness);
                    });

                    if (floorComponent) {
                        const floorNumber = Math.round(floorComponent.object.position.y / floorHeight);
                        createAnimatedFloorView(floorNumber);
                    }
                } else {
                    // Check if we clicked another floor while one is active
                    const floorComponent = sceneIntersects.find(intersect => {
                        const objectY = intersect.object.position.y;
                        const currentFloorY = window.activeFloorGroup.position.y;

                        return (intersect.object.isFloor ||
                            (objectY % floorHeight < floorHeight + wallThickness &&
                                objectY % floorHeight > -wallThickness)) &&
                            Math.abs(Math.round(objectY / floorHeight) -
                                Math.round(currentFloorY / floorHeight)) > 0.1;
                    });

                    if (floorComponent) {
                        const floorNumber = Math.round(floorComponent.object.position.y / floorHeight);
                        createAnimatedFloorView(floorNumber);
                    }
                    else if (sceneIntersects.length === 0) {
                        // We clicked on empty space
                        resetFloorPosition();
                    }
                    if (window.activeMenu) {
                        document.body.removeChild(window.activeMenu);
                        window.activeMenu = null;
                    }
                }
            }

            // New simplified menu for floor components
            function createFloorMenu(x, y, component, floorNumber) {
                // Remove existing menu if any
                if (window.activeMenu) {
                    document.body.removeChild(window.activeMenu);
                    window.activeMenu = null;
                }

                const menu = document.createElement('div');
                menu.className = 'quadrant-menu';
                menu.style.position = 'fixed';
                menu.style.left = `${x}px`;
                menu.style.top = `${y}px`;

                const showCamera = document.createElement('div');
                showCamera.className = 'quadrant-menu-item';
                showCamera.textContent = 'View Camera';

                showCamera.addEventListener('click', () => {
                    const cameraUrl = `https://player.castr.com/live_1deb88e0b56e11ef8f0e3fcb84ef4d27`;
                    replaceWithIframe(cameraUrl);
                    showCameraModal();
                });

                menu.appendChild(showCamera);
                document.body.appendChild(menu);
                window.activeMenu = menu;
            }
            function createQuadrantMenu(x, y, quadrant, floorNumber, quadrantX, quadrantZ) {
                console.log("Creating menu at:", x, y);
                console.log("Quadrant:", quadrant);

                const quadrantId = `${floorNumber}-${quadrantX}-${quadrantZ}`;

                // Remove existing menu if any
                if (window.activeMenu) {
                    console.log("Removing existing menu");
                    document.body.removeChild(window.activeMenu);
                    window.activeMenu = null;
                }

                const menu = document.createElement('div');
                menu.className = 'quadrant-menu';
                menu.style.position = 'fixed';
                menu.style.left = `${x}px`;
                menu.style.top = `${y}px`;
                menu.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                menu.style.color = 'white';
                menu.style.padding = '10px';
                menu.style.borderRadius = '5px';
                menu.style.zIndex = '1000';
                menu.style.border = '1px solid white';
                menu.style.minWidth = '150px';

                const defineAsDangerous = document.createElement('div');
                defineAsDangerous.className = 'quadrant-menu-item';
                defineAsDangerous.style.cursor = 'pointer';
                defineAsDangerous.style.padding = '5px 10px';
                defineAsDangerous.textContent = dangerousQuadrants.has(quadrantId) ? 'Remove Dangerous Status' : 'Define as Dangerous';

                const showCamera = document.createElement('div');
                showCamera.className = 'quadrant-menu-item';
                showCamera.style.cursor = 'pointer';
                showCamera.style.padding = '5px 10px';
                showCamera.textContent = 'View Camera';

                showCamera.addEventListener('click', () => {
                    const cameraUrl = `https://player.castr.com/live_1deb88e0b56e11ef8f0e3fcb84ef4d27`;
                    replaceWithIframe(cameraUrl);
                    showCameraModal();
                });

                defineAsDangerous.addEventListener('click', () => {
                    if (dangerousQuadrants.has(quadrantId)) {
                        dangerousQuadrants.delete(quadrantId);
                        quadrant.material.color.setHex(quadrant.userData.originalColor || 50630);
                        if (quadrant.userData.warningSign) {
                            quadrant.remove(quadrant.userData.warningSign);
                            quadrant.userData.warningSign = null;
                        }
                    } else {
                        dangerousQuadrants.add(quadrantId);
                        quadrant.userData.originalColor = quadrant.material.color.getHex();
                        quadrant.material.color.setHex(0xff0000);

                        const warningSign = createWarningSign();
                        warningSign.position.set(0, 0, 1);
                        quadrant.add(warningSign);
                        quadrant.userData.warningSign = warningSign;
                    }

                    if (window.activeMenu) {
                        document.body.removeChild(window.activeMenu);
                        window.activeMenu = null;
                    }
                });

                menu.appendChild(defineAsDangerous);
                menu.appendChild(showCamera);
                document.body.appendChild(menu);
                window.activeMenu = menu;

                console.log("Menu added to DOM:", document.body.contains(menu));
                console.log("Menu: ", menu);
            }

            function showCameraModal() {
                const modal = document.getElementById('floorInfoModal');
                modal.style.display = 'block';
                if (window.activeMenu) {
                    document.body.removeChild(window.activeMenu);
                    window.activeMenu = null;

                }
            }

            

            // Replace the updateBlinkingItems function with this version
            function updateBlinkingItems() {
                const currentTime = Date.now();
                if (currentTime - lastBlinkTime > blinkInterval) {
                    blinkingItems.forEach(item => {
                        if (item.material) {
                            item.material.opacity = item.material.opacity === 1 ? 0.3 : 1;
                        }
                    });
                    lastBlinkTime = currentTime;
                }
            }


            window.replaceWithIframe = function (url) {
                const contentDiv = document.getElementById('floorInfoContent');

                // Clear the existing content
                contentDiv.innerHTML = '';

                // Create a new iframe
                const iframe = document.createElement('iframe');
                iframe.src = url;
                iframe.style.width = '100%';
                iframe.style.aspectRatio = '16/9'; // Maintains a proper video aspect ratio
                iframe.style.minHeight = '340px';
                iframe.frameBorder = '0';
                iframe.allow = 'autoplay';
                iframe.allowFullscreen = true;

                // Add the iframe to the content div
                contentDiv.appendChild(iframe);
            }

            


            function createBuildingLines() {
                const corners = [
                    [-buildingWidth/2, buildingDepth/2],
                    [buildingWidth/2, buildingDepth/2],
                    [buildingWidth/2, -buildingDepth/2],
                    [-buildingWidth/2, -buildingDepth/2]
                ];

                corners.forEach((corner) => {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    points.push(new THREE.Vector3(corner[0], 0, corner[1]));
                    points.push(new THREE.Vector3(corner[0], totalFloors * floorHeight, corner[1]));
                    geometry.setFromPoints(points);
                    const line = new THREE.Line(geometry, materials.line);
                    scene.add(line);
                });
            }

            const keyboard = {};
            const moveSpeed = 0.3;
            const rotationSpeed = 0.02;

            window.addEventListener('keydown', (e) => {
            keyboard[e.key.toLowerCase()] = true;
            });

            window.addEventListener('keyup', (e) => {
            keyboard[e.key.toLowerCase()] = false;
            });

            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && window.activeFloorGroup) {
                    resetFloorPosition();
                    if (window.activeMenu) {
                        document.body.removeChild(window.activeMenu);
                        window.activeMenu = null;
                    }
                }
            });


            function animate() {
                requestAnimationFrame(animate);
                updateBlinkingItems();
                renderer.render(scene, camera);
                if (controls) controls.update();
                updateCameraMovement();
            }

            window.applyWifi = function () {
                wifiFloors.clear();
                document.querySelectorAll('#wifiFloors input:checked').forEach(input => {
                    wifiFloors.add(parseInt(input.value));
                });
                updateWifiFloors();
                document.getElementById('wifiModal').style.display = 'none';
            };


           function createNumberSprite(_number) {
                const canvas = document.createElement('canvas');
                canvas.width = 512;
                canvas.height = 512;
                const context = canvas.getContext('2d');

                // Draw a number in the center of the canvas
                context.fillStyle = 'white'; // Text color
                context.fillRect(0, 0, 512, 512); // White background
                context.fillStyle = 'black';
                context.font = 'bold 256px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(_number, 256, 256);

                // Create a texture and material from the canvas
                const texture = new THREE.CanvasTexture(canvas);
                const material = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(material);

                return sprite;
            }

            function toggleWorkers() {
                const btn = document.getElementById('toggleWorkers');
                if (!isWorkersVisible) {
                    // Define one color per group
                    const groupColors = {
                        'group1': '#4CAF50',     // Green
                        'group2': '#2196F3',     // Blue
                        'group3': '#FFC107',     // Amber
                        'group4': '#FF5722',     // Deep Orange
                        'group5': '#9C27B0',     // Purple
                        'group6': '#009688',     // Teal
                        'group7': '#795548',     // Brown
                        'group8': '#673AB7',     // Deep Purple
                        'group9': '#00BCD4',     // Cyan
                        'group10': '#FF9800',     // Orange
                        'group11': '#F44336',     // Red
                        'group12': '#3F51B5',     // Indigo
                        'group13': '#8BC34A',     // Light Green
                        'group14': '#607D8B',     // Blue Grey
                        'group15': '#FF4081',     // Pink
                        'group16': '#00E676',     // Green Accent
                        'group17': '#1DE9B6',     // Teal Accent
                        'group18': '#D500F9',     // Purple Accent
                        'group19': '#FFEA00',     // Yellow Accent
                        'group20': '#FF3D00'      // Deep Orange Accent
                    };

                    const groupIds = Object.keys(groupColors);
                    let workerNumber = 1;
                    for (let floor = 0; floor < totalFloors; floor++) {
                        const numWorkers = Math.floor(Math.random() * 4) + 1;
                        for (let i = 0; i < numWorkers; i++) {
                            // Select a group for this worker
                            const selectedGroup = groupIds[Math.floor(Math.random() * groupIds.length)];

                            // Get color for the group
                            const helmetColor = groupColors[selectedGroup];

                            const helmet = createHelmetSprite(helmetColor);

                            // Position helmet
                            const randLocation = getRandomLocation(buildingWidth, buildingDepth);
                            helmet.position.set(
                                randLocation.x,
                                floor * floorHeight + floorHeight / 2,
                                randLocation.y
                            );
                            helmet.scale.set(2, 2, 2);

                            // Add worker group metadata
                            helmet.userData = { group: selectedGroup };

                            // Add number
                            const number = createNumberSprite(workerNumber);
                            number.position.set(0, 1.5, 0);
                            helmet.add(number);

                            scene.add(helmet);
                            workers.push(helmet);
                            workerNumber++;
                        }
                    }
                    btn.textContent = 'Hide Workers';
                } else {
                    // Remove helmets from the building
                    workers.forEach(helmet => scene.remove(helmet));
                    workers = [];
                    btn.textContent = 'Show Workers';
                }
                isWorkersVisible = !isWorkersVisible;
            }

            
            
            document.getElementById('toggleWorkers').addEventListener('click', toggleWorkers);


            window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            });

            document.getElementById('floorAmount').addEventListener('click', () => {
                document.getElementById('floorModal').style.display = 'block';
            });

            document.getElementById('lobbyFloor').addEventListener('click', () => {
                document.getElementById('lobbyFloorModal').style.display = 'block';
            });

            document.getElementById('rojiBoxes').addEventListener('click', toggleRojiBoxes);
            document.getElementById('toggleElevators').addEventListener('click', toggleElevators);
            document.getElementById('wifiConfig').addEventListener('click', showWifiModal);

            window.updateFloors = function () {
                const newFloorCount = parseInt(document.getElementById('floorInput').value);
                if (newFloorCount > 0 && newFloorCount <= 100) {
                    while (scene.children.length > 0) {
                        scene.remove(scene.children[0]);
                    }
                    totalFloors = newFloorCount;
                    createBuilding();
                    // createBuildingLines();
                    if (isWorkersVisible) { toggleWorkers(); }
                    camera.position.set(0, totalFloors * floorHeight / 2, totalFloors * 2.5);
                    // camera.lookAt(0, totalFloors * floorHeight / 2, 0);
                    raycaster.setFromCamera(mouse, camera);
                }
                document.getElementById('floorModal').style.display = 'none';
            }

            window.updateFloorNames = function (names) {
                floorsNames = names;
            }

            window.showZones = function(zones) {
                currentZones.forEach(item => {
                    if (item.parent) {
                        item.parent.remove(item);
                    } else {
                        scene.remove(item);
                    }
                });
                currentZones = [];
                zones.forEach(zone => {
                    addZone(zone)
                })
            }

            window.addCameras = function(cams){
                    const objLoader = new OBJLoader();
                    objLoader.load(
                        'models/cam/cam.obj',
                        (camModel) => {
                            camModel.scale.set(0.1, 0.1, 0.1);
                            cams.forEach(cam => {
                                const camModelClone = camModel.clone();
                                const {name, streamUrl, location} = cam;
                                const { floor_physical, xy, is_exact } = location;
                                const worldCoords = normalizedToWorldCoords(xy[0], xy[1], buildingWidth, buildingDepth);
                                let finalX = worldCoords.x;
                                let finalZ = worldCoords.z;

                                if (!is_exact) {
                                    finalX = addRandomization(finalX, 2);
                                    finalZ = addRandomization(finalZ, 2);
                                }

                                const y = floor_physical * floorHeight + 1;
                                camModelClone.position.set(finalX, y, finalZ);
                                camModelClone.traverse((child) => {
                                    if (child instanceof THREE.Mesh && child.geometry) {
                                        const camGeometry = child.geometry;
                                        camGeometry.computeBoundingBox();
                                        camGeometry.boundingBox.expandByScalar(0.1)
                                        child.material = new THREE.MeshPhongMaterial({
                                            color: 0x000000,
                                            specular: 0x111111,
                                            shininess: 200
                                        });
                                        child.userData = { name, streamUrl };

                                    }
                                });
                                scene.add(camModelClone);
                            });

                        },
                        (xhr) => {
                            console.log((xhr.loaded / xhr.total) * 100 + '% loaded');
                        },
                        (error) => {
                            console.error('An error occurred while loading the OBJ file:', error);
                        }
                    );

            }

            function updateCameraMovement() {
                if (keyboard['w']) camera.translateZ(-moveSpeed);
                if (keyboard['s']) camera.translateZ(moveSpeed);
                if (keyboard['a']) camera.translateX(-moveSpeed);
                if (keyboard['d']) camera.translateX(moveSpeed);
                if (keyboard['q']) camera.rotation.x += rotationSpeed;
                if (keyboard['e']) camera.rotation.x -= rotationSpeed;
                if (keyboard['arrowleft']) camera.rotation.y += rotationSpeed;
                if (keyboard['arrowright']) camera.rotation.y -= rotationSpeed;
                if (keyboard['arrowup']) camera.translateY(moveSpeed);
                if (keyboard['arrowdown']) camera.translateY(-moveSpeed);
            }

            init();

        }

            
    </script>
    <script>
    // Check if the current window is inside an iframe
    if (window.self !== window.top) {
        // Hide the controls div
        const controlsDiv = document.getElementById('controls');
        if (controlsDiv) {
            controlsDiv.style.display = 'none';
        }
        const instructionsDiv = document.getElementById('instructions');
        if (instructionsDiv) {
            instructionsDiv.style.display = 'none';
        }
    }
    </script>
    <div id="wifiModal" class="modal">
       <h3>Select floors for WIFI</h3>
       <div id="wifiFloors" style="max-height: 300px; overflow-y: auto;"></div>
       <button onclick="applyWifi()">Apply</button>
       <button onclick="document.getElementById('wifiModal').style.display='none'">Cancel</button>
    </div>
</body>
</html>
